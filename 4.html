
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="robots" content="noindex, nofollow">
    <meta name="googlebot" content="noindex, nofollow">










    <script type="text/javascript" src="/js/lib/dummy.js"></script>




    <link rel="stylesheet" type="text/css" href="/css/normalize.css">





    <link rel="stylesheet" type="text/css" href="/css/result-light.css">




    <style type="text/css">
        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            text-align: center;
            color: #ffff00;
        }

        body {
            overflow: hidden;
        }
    </style>

    <title>hw4 prototype</title>







    <script type='text/javascript'>
//<![CDATA[
        window.onload = function () {
            var camera, scene, renderer, controls;
            var puck;
            var agents = [], blocks = [];
            var angle = 0;
            var targetCatch = false;
            var targetOmega = 0.3;

            var mass = 1;
            var clock = new THREE.Clock();

            var target = new THREE.Vector3();
            var puck1, raycaster, pickables = [], mouse = new THREE.Vector2();

            var agenthalfsize = 5, tmp = new THREE.Vector3();

            var Agent = function (mesh, initPos) {
                this.pos = new THREE.Vector3();
                if (initPos) this.pos.copy(initPos);

                this.vel = new THREE.Vector3();
                this.force = new THREE.Vector3();
                this.target = new THREE.Vector3();
                this.angle = 0
                this.mesh = mesh.clone();
                scene.add(this.mesh)
                this.maxSpeed = 30;
                this.maxForce = 30;

                this.setTarget = function (target) {
                    this.target.copy(target);
                }

                this.update = function (dt) {
                    // compute force
                    this.force = this.target.clone().sub(this.pos).setLength(this.maxSpeed).sub(this.vel);

                    // force clamping
                    if (this.force.length() > this.maxForce)
                        this.force.setLength(this.maxForce);
                    this.vel.add(this.force.clone().multiplyScalar(dt));

                    // velocity clamping
                    if (this.vel.length() > this.maxSpeed)
                        this.vel.setLength(this.maxSpeed);
                    this.pos.add(this.vel.clone().multiplyScalar(dt));

                    if (this.vel.length() > 0.001) {
                        this.angle = Math.atan2(-this.vel.z, this.vel.x);
                    }
                    this.mesh.position.copy(this.pos);
                    this.mesh.rotation.y = this.angle;

                    // catch handling
                    if (this.pos.distanceTo(this.target) < 2) {
                        this.vel.set(0, 0, 0);
                        angle = Math.random() * Math.PI * 2;
                    }

                }
            }
            Agent.prototype = {
                emptyNbdd: function () {
                    this.nbhd = [];
                },
                cohesion: function () {
                    // set pos as the average of my nbhd.pos
                    if (this.nbhd.length === 0) return null;
                    var sum = 0;
                    for (var i = 0; i < this.nbhd.length; i++)
                        sum += this.nbhd[i].pos;
                    return sum / this.nbhd.length;;
                },
                print: function () {
                    console.log('name: ' + this.name);
                    // print all my neighbors
                    console.log('my nbhd:')
                    for (var i = 0; i < this.nbhd.length; i++)
                        console.log('  ' + this.nbhd[i].name);
                },
                separation: function () {

                },
                alignment: function () {

                }

            }

            init();
            animate();

            function init() {
                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
                camera.position.z = 180;
                camera.position.y = 150;
                scene.add(camera);

                var gridXZ = new THREE.GridHelper(100, 10);
                gridXZ.setColors(new THREE.Color(0xff0000), new THREE.Color(0xffffff));
                scene.add(gridXZ);

                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x888888);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                document.body.appendChild(renderer.domElement);

                //////////////////////
                var geometry = new THREE.Geometry();
                // add vertices
                geometry.vertices.push(new THREE.Vector3(-0, 0, -5));
                geometry.vertices.push(new THREE.Vector3(30 - 0, 0, 0));
                geometry.vertices.push(new THREE.Vector3(-0, 10, 0));
                // add faces
                geometry.faces.push(new THREE.Face3(0, 1, 2));
                // build necessary information
                geometry.computeBoundingSphere();
                geometry.computeFaceNormals();
                geometry.computeVertexNormals();
                var mesh = new THREE.Mesh(geometry, new THREE.MeshNormalMaterial({ side: THREE.DoubleSide }));
                var meshL = mesh.clone();
                var geometryR = new THREE.Geometry();
                geometryR.vertices.push(new THREE.Vector3(-0, 0, 5));
                geometryR.vertices.push(new THREE.Vector3(30 - 0, 0, 0));
                geometryR.vertices.push(new THREE.Vector3(-0, 10, 0));
                geometryR.faces.push(new THREE.Face3(0, 1, 2));
                geometryR.computeBoundingSphere();
                geometryR.computeFaceNormals();
                geometryR.computeVertexNormals();
                var meshR = new THREE.Mesh(geometryR, new THREE.MeshNormalMaterial({ side: THREE.DoubleSide }));
                var geometryB = new THREE.Geometry();
                geometryB.vertices.push(new THREE.Vector3(-0, 0, 5));
                geometryB.vertices.push(new THREE.Vector3(-0, 10, 0));
                geometryB.vertices.push(new THREE.Vector3(0, 0, -5));
                geometryB.faces.push(new THREE.Face3(0, 1, 2));
                geometryB.computeBoundingSphere();
                geometryB.computeFaceNormals();
                geometryB.computeVertexNormals();
                var meshB = new THREE.Mesh(geometryB, new THREE.MeshNormalMaterial({ side: THREE.DoubleSide }));
                var boat = new THREE.Object3D();
                /*meshL.position.x = -25;
                meshB.position.x = -25;
                meshR.position.x = -25;*/
                boat.add(meshL);
                boat.add(meshR);
                boat.add(meshB);

                //scene.add(box); low + Math.floor( Math.random() * ( high - low + 1 ) );
                agents.push(new Agent(boat, new THREE.Vector3(-100 + Math.floor(Math.random() * 201), 0, -100 + Math.floor(Math.random() * 201))));
                agents.push(new Agent(boat, new THREE.Vector3(-100 + Math.floor(Math.random() * 201), 0, -100 + Math.floor(Math.random() * 201))));
                agents.push(new Agent(boat, new THREE.Vector3(-100 + Math.floor(Math.random() * 201), 0, -100 + Math.floor(Math.random() * 201))));
                agents.push(new Agent(boat, new THREE.Vector3(-100 + Math.floor(Math.random() * 201), 0, -100 + Math.floor(Math.random() * 201))));
                agents.push(new Agent(boat, new THREE.Vector3(-100 + Math.floor(Math.random() * 201), 0, -100 + Math.floor(Math.random() * 201))));
                agents.push(new Agent(boat, new THREE.Vector3(-100 + Math.floor(Math.random() * 201), 0, -100 + Math.floor(Math.random() * 201))));
                //console.log(Math.random());

                puck = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 2, 20), new THREE.MeshNormalMaterial());
                scene.add(puck);

                //target.set(50, 0, 50)
                //agent.setTarget(target);
                plane = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshBasicMaterial({ visible: false }));
                scene.add(plane);
                plane.rotation.x = -Math.PI / 2;
                pickables = [plane];

                raycaster = new THREE.Raycaster();
                document.addEventListener('mousedown', onDocumentMouseDown, false);

                blocks.push(new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 10, 20), new THREE.MeshNormalMaterial({ color: 'pink' })));
                blocks.push(new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 10, 20), new THREE.MeshNormalMaterial({ color: 'pink' })));
                blocks.push(new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 10, 20), new THREE.MeshNormalMaterial({ color: 'pink' })));
                blocks.push(new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 10, 20), new THREE.MeshNormalMaterial({ color: 'pink' })));
                for (var i = 0; i < blocks.length; i++) {
                    blocks[i].position.set(-100 + Math.floor(Math.random() * 201), 0, -100 + Math.floor(Math.random() * 201));
                    scene.add(blocks[i]);
                }
            }

            function bb() {
                for (var i = 0; i < blocks.length; i++) {//console.log('jklj');
                    blocks[i].position.set(-100 + Math.floor(Math.random() * 201), 0, -100 + Math.floor(Math.random() * 201));
                }
                for (var i = 0; i < agents.length; i++) {//console.log('sdfas');
                    agents[i].pos.set(-100 + Math.floor(Math.random() * 201), 0, -100 + Math.floor(Math.random() * 201));
                }
            }

            function onDocumentMouseDown(event) {
                event.preventDefault();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // find intersections
                raycaster.setFromCamera(mouse, camera);
                var intersects = raycaster.intersectObjects(pickables);
                if (intersects.length > 0) {
                    puck.position.copy(intersects[0].point);
                }
            }

            function animate() {
                var dt = clock.getDelta(); // delta-time

                angle += targetOmega * dt;

                //target.set(100 * Math.cos(angle), 0, 100 * Math.sin(angle));
                target.copy(puck.position);
                //console.log(puck.position);
                //puck.position.copy(target);

                for (var i = 0; i < agents.length; i++) {
                    agents[i].update(dt);
                    agents[i].setTarget(target);
                    var mm = 100, xx, zz, sqrtt;
                    for (var ii = 0; ii < blocks.length; ii++) {
                        //console.log(blocks[ii].position.x - agents[i].pos.x);
                        xx = blocks[ii].position.x - agents[i].pos.x;
                        zz = blocks[ii].position.z - agents[i].pos.z;
                        sqrtt = Math.sqrt(xx * xx + zz * zz);
                        if (sqrtt < mm) {//console.log('sdkf')
                            tmp = (blocks[ii].position.clone().sub(agents[i].pos));
                            //console.log(tmp);
                            mm = sqrtt;
                        }
                    }
                    var w = THREE.Vector3(), tmpProj = THREE.Vector3();
                    tmpProj = tmp.projectOnVector(agents[i].vel);
                    w = tmpProj.clone().sub(tmp);
                    //console.log(agents[i].force)
                    w.multiplyScalar(100);
                    agents[i].force.multiplyScalar(Math.pow(sqrtt / (50 * (agents[i].vel.length() / 30)), 5));
                    var x1, z1;//console.log(puck.position.x)
                    x1 = Math.abs(puck.position.x - agents[i].pos.x);
                    z1 = Math.abs(puck.position.z - agents[i].pos.z);
                    //console.log(Math.sqrt(x1*x1+z1*z1))
                    if (Math.sqrt(x1 * x1 + z1 * z1) < 30) {
                        bb();
                    }
                }


                controls.update();
                requestAnimationFrame(animate);
                render();
            }

            function render() {
                renderer.render(scene, camera);
            }

        }//]]>

    </script>


</head>

<body>
    <div id="info">hw4 </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
    <script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js">


    </script>
    <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>


</body>

</html>
